{
    "patches": [
        {
            "label": "2025-11-11_22-34-44",
            "content": "@@ -292,254 +292,43 @@\n %22)%0A%0A\n-from __future__ import annotations%0A%0Afrom dataclasses import dataclass%0Afrom typing import List, optional%0A%0AClass CalibreIncomparativeError(ValueError):%0A    pass%0AClass BicoOcupadoError(RuntimeError):%0A    pass%0A%0AClass SemGrafiteNoBicoError(RunTimeError)%0A%0A\n+        import random%0A        %0A        \n",
            "lines": "13"
        },
        {
            "label": "2025-11-11_22-40-47",
            "content": "@@ -1,12 +1,306 @@\n+Class Draft:%0A    def __init__(self, model, color, tip+size):%0A        self.model = model%0A        self.color = color%0A        self.tip_size = tip_size%0A        self.lead = None%0A        print(%22Array de inteiros vazio:%22, numeros)%0A        print(%22Array de obejtos vazio:%22, obejetos)%0A        print(%22-%22)%0A\n %0Afrom __futu\n",
            "lines": "22"
        },
        {
            "label": "2025-11-11_22-41-02",
            "content": "@@ -1,12 +1,13 @@\n+%0A\n from __futur\n@@ -201,16 +201,16 @@\n   pass%0A%0A\n+\n Class Se\n@@ -248,268 +248,4 @@\n r)%0A%0A\n-HARDNESS_COMSUMPTION = %7B%0A    %22HB%22: 1,%0A    %222B%22: 2,%0A    %224B%22: 4,%0A    %226B%22: 6,%0A%7D%0A%0AClass Grafite:%0A    def __init__(self, clibre: float, dureza: str, tamanho: float):%0A        self.calibre = calibre%0A        self.dereza = dureza%0A        self.tamanho = tamanho%0A        %0A%0A\n",
            "lines": "13"
        },
        {
            "label": "2025-11-11_22-49-50",
            "content": "@@ -505,19 +505,10 @@\n         \n-%0A        \n %0A%0A\n",
            "lines": "26"
        },
        {
            "label": "2025-11-11_22-52-44",
            "content": "@@ -418,22 +418,30 @@\n     \n+self.\n calibre\n-: float\n+ = calibre\n %0A   \n@@ -449,179 +449,58 @@\n     \n-du\n+self.de\n re\n-a\n za\n-: str%0A        tamanho_mm: int%0A%0A        def consumir(self, mm: int) -%3E int:%0A            consumido = min (self.tamanho_mm, mm)%0A            self.tamanho_mm -= consumid\n+ = dureza%0A        self.tamanho = tamanh\n o%0A  \n@@ -505,22 +505,16 @@\n         \n-    %0A%0A\n %0A       \n",
            "lines": "27"
        },
        {
            "label": "2025-11-11_22-58-42",
            "content": "@@ -626,201 +626,8 @@\n     \n-return consumido%0A        %0A        def _str_(self) -%3E str:%0A            return f%22Grafite(calibre=%7Bself.calibre%7D, dureza=%7Bself.dureza%7D, tamanho_mm=%7Bself.tamanho_mm%7D)%22%0A        %0A%0AClass Lapiseira:%0A%0A%0A\n %0A%0A%0A \n",
            "lines": "33"
        },
        {
            "label": "2025-11-11_23-04-24",
            "content": "@@ -817,480 +817,8 @@\n ra:%0A\n-    def __init__(self, calibre: float) -%3E None:%0A    self.bico: Optional%5BGrafite%5D = None%0Aself.tambor: List%5BGrafite%5D = %5B%5D%0A%0A%0Adef inserir_grafite(self, calibre: float, dureza: str, tamanho_mm: int) -%3E None:%0A%22%22%22Insere um grafite no final do tambor.%0ALevanta CalibreIncompativelError se o calibre n%C3%A3o for compat%C3%ADvel.%0A%22%22%22%0Aif abs(float(calibre) - self.calibre) %3E 1e-6:%0Araise CalibreIncompativelError(%0Af%22Calibre do grafite (%7Bcalibre%7D) incompat%C3%ADvel com lapiseira (%7Bself.calibre%7D).%22%0A)\n %0A%0A%0A%0A\n",
            "lines": "42"
        },
        {
            "label": "2025-11-11_23-17-00",
            "content": "@@ -1290,303 +1290,8 @@\n %22%0A)%0A\n-if dureza not in HARDNESS_CONSUMPTION:%0Araise ValueError(f%22Dureza desconhecida: %7Bdureza%7D. Op%C3%A7%C3%B5es: %7Blist(HARDNESS_CONSUMPTION.keys())%7D%22)%0Aif tamanho_mm %3C= 0:%0Araise ValueError(%22Tamanho do grafite deve ser positivo em mm.%22)%0Ag = Grafite(float(calibre), dureza, int(tamanho_mm))%0Aself.tambor.append(g)%0A%0A\n %0A%0A%0A%0A\n",
            "lines": "54"
        },
        {
            "label": "2025-11-11_23-19-35",
            "content": "@@ -1585,41 +1585,8 @@\n g)%0A%0A\n-def puxar_grafite(self) -%3E None:%0A\n %0A%0A%0A%0A\n",
            "lines": "61"
        },
        {
            "label": "2025-11-11_23-22-39",
            "content": "@@ -1618,146 +1618,8 @@\n ne:%0A\n-    if self.bico is not None:%0Araise BicoOcupadoError(%22J%C3%A1 existe um grafite no bico %E2%80%94 remova-o antes de puxar outro.%22)%0Aif not self.tambor:%0A\n %0A%0A%0A%0A\n",
            "lines": "62"
        },
        {
            "label": "2025-11-11_23-23-15",
            "content": "@@ -1756,152 +1756,8 @@\n or:%0A\n-    raise IndexError(%22Tambor vazio: n%C3%A3o h%C3%A1 grafite para puxar.%22)%0Aself.bico = self.tambor.pop()%0A%0Adef remover_grafite(self) -%3E Optional%5BGrafite%5D:%0A\n %0A%0A%0A%0A\n",
            "lines": "65"
        },
        {
            "label": "2025-11-11_23-26-51",
            "content": "@@ -1900,300 +1900,9 @@\n e%5D:%0A\n-    return %7B%0A%22sucesso%22: True,%0A%22consumido_mm%22: int(consumido),%0A%22mensagem%22: %22Folha escrita com sucesso.%22,%0A%22grafite_restante_mm%22: int(g.tamanho_mm),%0A%7D%0A%0Areturn %7B%0A%22sucesso%22: True,%0A%22consumido_mm%22: int(consumido),%0A%22mensagem%22: %22Folha escrita com sucesso.%22,%0A%22grafite_restante_mm%22: int(g.tamanho_mm),%0A%7D\n+%0A\n %0A%0A%0A \n",
            "lines": "69"
        },
        {
            "label": "2025-11-12_00-00-47",
            "content": "@@ -2195,1164 +2195,8 @@\n %7D%0A%0A%0A\n-def status(self) -%3E str:%0Abico_str = str(self.bico) if self.bico else %22(vazio)%22%0Atambor_str = %22, %22.join(repr(g) for g in self.tambor) if self.tambor else %22(vazio)%22%0Areturn f%22Lapiseira %7Bself.calibre%7Dmm %7C Bico: %7Bbico_str%7D %7C Tambor: %7Btambor_str%7D%22%0A%0A%0Adef __repr__(self) -%3E str:%0Areturn f%22Lapiseira(calibre=%7Bself.calibre%7D, bico=%7Bself.bico%7D, tambor=%7Bself.tambor%7D)%22%0A%0A%0A%0A%0Aif __name__ == %22__main__%22:%0A# Exemplo de uso%0Alap = Lapiseira(0.5)%0Aprint(%22Criada:%22, lap)%0A%0A%0A%0A# Inserindo grafites corretos e um incorreto%0Alap.inserir_grafite(0.5, %22HB%22, 60)%0Alap.inserir_grafite(0.5, %222B%22, 50)%0Alap.inserir_grafite(0.5, %224B%22, 20)%0Aprint(%22Ap%C3%B3s inserir 3 grafites:%22, lap)%0A%0A%0A# Puxar grafite para o bico%0Alap.puxar_grafite()%0Aprint(%22Ap%C3%B3s puxar um grafite (%C3%BAltimo do tambor):%22, lap)%0A%0A%0A# Escrever folhas at%C3%A9 terminar ou ficar incompleto%0Awhile True:%0Atry:%0Ares = lap.escrever_folha()%0Aprint(res)%0Aif not res%5B%22sucesso%22%5D:%0Aprint(%22A escrita ficou incompleta ou grafite insuficiente %E2%80%94 status:%22, lap)%0Abreak%0A# se o grafite foi removido, poderemos puxar outro%0Aif lap.bico is None:%0Aprint(%22Bico vazio %E2%80%94 puxe outro grafite do tambor se houver.%22)%0Abreak%0Aexcept SemGrafiteNoBicoError as e:%0Aprint(%22Erro:%22, e)%0Abreak%0A%0A%0A\n     \n",
            "lines": "80"
        },
        {
            "label": "2025-11-12_00-54-18",
            "content": "@@ -3342,130 +3342,8 @@\n , e)\n-%0A%0Aprint(%22Bico vazio %E2%80%94 puxe outro grafite do tambor se houver.%22)%0Abreak%0Aexcept SemGrafiteNoBicoError as e:%0Aprint(%22Erro:%22, e)\n %0Abre\n",
            "lines": "128"
        },
        {
            "label": "2025-11-12_12-59-15",
            "content": "@@ -3471,136 +3471,8 @@\n eak%0A\n-print(%22Bico vazio %E2%80%94 puxe outro grafite do tambor se houver.%22)%0Abreak%0Aexcept SemGrafiteNoBicoError as e:%0Aprint(%22Erro:%22, e)%0Abreak%0A%0A\n %0A%0A  \n",
            "lines": "133"
        },
        {
            "label": "2025-11-12_13-07-16",
            "content": "@@ -2727,10 +2727,888 @@\n lap.inse\n+rir_grafite(0.5, %222B%22, 50)%0Alap.inserir_grafite(0.5, %224B%22, 20)%0Aprint(%22Ap%C3%B3s inserir 3 grafites:%22, lap)%0A%0A%0A# Puxar grafite para o bico%0Alap.puxar_grafite()%0Aprint(%22Ap%C3%B3s puxar um grafite (%C3%BAltimo do tambor):%22, lap)%0A%0A%0A# Escrever folhas at%C3%A9 terminar ou ficar incompleto%0Awhile True:%0Atry:%0Ares = lap.escrever_folha()%0Aprint(res)%0Aif not res%5B%22sucesso%22%5D:%0Aprint(%22A escrita ficou incompleta ou grafite insuficiente %E2%80%94 status:%22, lap)%0Abreak%0A# se o grafite foi removido, poderemos puxar outro%0Aif lap.bico is None:%0Aprint(%22Bico vazio %E2%80%94 puxe outro grafite do tambor se houver.%22)%0Abreak%0Aexcept SemGrafiteNoBicoError as e:%0Aprint(%22Erro:%22, e)%0A%0Aprint(%22Bico vazio %E2%80%94 puxe outro grafite do tambor se houver.%22)%0Abreak%0Aexcept SemGrafiteNoBicoError as e:%0Aprint(%22Erro:%22, e)%0Abreak%0Aprint(%22Bico vazio %E2%80%94 puxe outro grafite do tambor se houver.%22)%0Abreak%0Aexcept SemGrafiteNoBicoError as e:%0Aprint(%22Erro:%22, e)%0Abreak%0A%0A%0A%0A        \n %0A%0A\n",
            "lines": "139"
        },
        {
            "label": "2025-11-12_13-31-20",
            "content": "@@ -2636,8 +2636,101 @@\n %22, lap)%0A\n+%0A%0A%0A# Inserindo grafites corretos e um incorreto%0Alap.inserir_grafite(0.5, %22HB%22, 60)%0Alap.inse%0A%0A\n",
            "lines": "101"
        },
        {
            "label": "2025-11-12_13-38-41",
            "content": "@@ -2579,8 +2579,65 @@\n __%22:%0A# E\n+xemplo de uso%0Alap = Lapiseira(0.5)%0Aprint(%22Criada:%22, lap)%0A\n",
            "lines": "94"
        },
        {
            "label": "2025-11-12_13-45-52",
            "content": "@@ -1968,8 +1968,619 @@\n ensagem%22\n+: %22Folha escrita com sucesso.%22,%0A%22grafite_restante_mm%22: int(g.tamanho_mm),%0A%7D%0A%0Areturn %7B%0A%22sucesso%22: True,%0A%22consumido_mm%22: int(consumido),%0A%22mensagem%22: %22Folha escrita com sucesso.%22,%0A%22grafite_restante_mm%22: int(g.tamanho_mm),%0A%7D%0A%0A%0Adef status(self) -%3E str:%0Abico_str = str(self.bico) if self.bico else %22(vazio)%22%0Atambor_str = %22, %22.join(repr(g) for g in self.tambor) if self.tambor else %22(vazio)%22%0Areturn f%22Lapiseira %7Bself.calibre%7Dmm %7C Bico: %7Bbico_str%7D %7C Tambor: %7Btambor_str%7D%22%0A%0A%0Adef __repr__(self) -%3E str:%0Areturn f%22Lapiseira(calibre=%7Bself.calibre%7D, bico=%7Bself.bico%7D, tambor=%7Bself.tambor%7D)%22%0A%0A%0A%0A%0Aif __name__ == %22__main__%22:%0A# E\n",
            "lines": "92"
        },
        {
            "label": "2025-11-12_14-01-58",
            "content": "@@ -1968,9 +1968,8 @@\n ensagem%22\n-%0A\n",
            "lines": "67"
        },
        {
            "label": "2025-11-12_14-06-30",
            "content": "@@ -1,8 +1,77 @@\n+from __future__ import annotations%0A%0Afrom dataclasses import dataclass\n %0Afrom ty\n@@ -88,17 +88,17 @@\n t List, \n-O\n+o\n ptional%0A\n@@ -102,363 +102,427 @@\n al%0A%0A\n-%0A\n-c\n+C\n lass \n-Lapiseira:%0A    def __init__(self, calibre: float) -%3E None:%0A        self.calibre = float(calibre)%0A        # bico represented as list for compatibility with expected string 'bico: %5B%5D' or '%5Bg\n+CalibreIncomparativeError(ValueError):%0A    pass%0AClass BicoOcupadoError(RuntimeError):%0A    pass%0A%0AClass SemGrafiteNoBicoError(RunTimeError)%0A%0AHARDNESS_COMSUMPTION = %7B%0A    %22HB%22: 1,%0A    %222B%22: 2,%0A    %224B%22: 4,%0A    %226B%22: 6,%0A%7D%0A%0AClass G\n rafite\n-%5D'\n+:\n %0A    \n-    self.bico: List%5Bstr%5D = %5B%5D%0A        # tambor as list of grafite representations%0A        self.tambor: List%5Bstr%5D = %5B%5D%0A%0A    def __str__(self\n+def __init__(self, clibre: float, dureza: str, tamanho: float):%0A        calibre: float%0A        dureaza: str%0A        tamanho_mm: int%0A%0A        def consumir(self, mm: int\n ) -%3E \n-str\n+int\n :%0A  \n@@ -531,1288 +531,1446 @@\n     \n-# For the first test we only need empty representations%0A        bico_str = '%5B%5D' if not self.bico else f%22%5B%7Bself.bico%5B0%5D%7D%5D%22%0A        tambor_str = '%3C%3E' if not self.tambor else '%3C' + ''.join(self.tambor) + '%3E'%0A        # calibre should be printed as in input (e.g., 0.5)%0A        calibre_str = (\n+    consumido = min (self.tamanho_mm, mm)%0A            self.tamanho_mm -= consumido%0A            return consumido%0A        %0A        def _\n str\n+_\n (self\n-.calibre)).rstrip('0').rstrip('.') if '.' in str(self.calibre) else str(self.calibre)%0A        return f%22calibre: %7Bcalibre_str%7D, bico: %7Bbico_str%7D, tambor: %7Btambor_str%7D%22%0A%0A%0Adef main() -%3E None:%0A    import sys%0A%0A    lap: Optional%5BLapiseira%5D = None%0A    for line in sys.stdin:%0A        line = line.strip()%0A        if not line:%0A            continue%0A        # echo command%0A        print(f%22$%7Bline%7D%22)%0A        parts = line.split()%0A        cmd = parts%5B0%5D%0A        if cmd == 'end':%0A            break%0A        if cmd == 'init':%0A            if len(parts) %3E= 2:%0A                try:%0A                    calibre = float(parts%5B1%5D)%0A                except ValueError:%0A                    calibre = 0.0%0A                lap = Lapiseira(calibre)%0A            else:%0A                # ignore malformed%0A                continue%0A        elif cmd == 'show':%0A            if lap is None:%0A                print('lapiseira\n+) -%3E str:%0A            return f%22Grafite(calibre=%7Bself.calibre%7D, dureza=%7Bself.dureza%7D, tamanho_mm=%7Bself.tamanho_mm%7D)%22%0A        %0A%0AClass Lapiseira:%0A    def __init__(self, calibre: float) -%3E None:%0A    self.bico: Optional%5BGrafite%5D = None%0Aself.tambor: List%5BGrafite%5D = %5B%5D%0A%0A%0Adef inserir_grafite(self, calibre: float, dureza: str, tamanho_mm: int) -%3E None:%0A%22%22%22Insere um grafite no final do tambor.%0ALevanta CalibreIncompativelError se o calibre n%C3%A3o for compat%C3%ADvel.%0A%22%22%22%0Aif abs(float(calibre) - self.calibre) %3E 1e-6:%0Araise CalibreIncompativelError(%0Af%22Calibre do grafite (%7Bcalibre%7D) incompat%C3%ADvel com lapiseira (%7Bself.calibre%7D).%22%0A)%0Aif dureza not in HARDNESS_CONSUMPTION:%0Araise ValueError(f%22Dureza desconhecida: %7Bdureza%7D. Op%C3%A7%C3%B5es: %7Blist(HARDNESS_CONSUMPTION.keys())%7D%22)%0Aif tamanho_mm %3C= 0:%0Araise ValueError(%22Tamanho do grafite deve ser positivo em mm.%22)%0Ag = Grafite(float(calibre), dureza, int(tamanho_mm))%0Aself.tambor.append(g)%0A%0Adef puxar_grafite(self) -%3E None:%0A    if self.bico is not None:%0Araise BicoOcupadoError(%22J%C3%A1 existe um grafite\n  n\n-a\n o \n-inicializada')%0A            else:%0A                print(lap)%0A%0A%0Aif __name__ == '__main__':%0A    main()\n+bico %E2%80%94 remova-o antes de puxar outro.%22)%0Aif not self.tambor:%0A    raise IndexError(%22Tambor vazio: n%C3%A3o h%C3%A1 grafite para puxar.%22)%0Aself.bico = self.tambor.pop()%0A%0Adef remover_grafite(self) -%3E Optional%5BGrafite%5D:%0A    return %7B%0A%22sucesso%22: True,%0A%22consumido_mm%22: int(consumido),%0A%22mensagem%22\n %0A\n",
            "lines": "67"
        },
        {
            "label": "2025-11-12_14-36-12",
            "content": "@@ -145,33 +145,185 @@\n     \n-self.bico: List%5Bstr%5D = %5B%5D\n+# bico represented as list for compatibility with expected string 'bico: %5B%5D' or '%5Bgrafite%5D'%0A        self.bico: List%5Bstr%5D = %5B%5D%0A        # tambor as list of grafite representations\n %0A   \n@@ -386,16 +386,80 @@\n -%3E str:%0A\n+        # For the first test we only need empty representations%0A\n         \n@@ -611,91 +611,175 @@\n     \n-s = str(self.calibre)%0A        if '.' in s:%0A            s = s.rstrip('0').rstrip('.'\n+# calibre should be printed as in input (e.g., 0.5)%0A        calibre_str = (str(self.calibre)).rstrip('0').rstrip('.') if '.' in str(self.calibre) else str(self.calibre\n )%0A  \n@@ -803,17 +803,27 @@\n libre: %7B\n-s\n+calibre_str\n %7D, bico:\n@@ -1020,32 +1020,55 @@\n        continue%0A\n+        # echo command%0A\n         print(f%22\n@@ -1417,32 +1417,67 @@\n           else:%0A\n+                # ignore malformed%0A\n                 \n@@ -1667,16 +1667,16 @@\n ain__':%0A\n+\n     main\n@@ -1682,26 +1682,4 @@\n n()%0A\n-# ...existing code...%0A\n",
            "lines": "54"
        },
        {
            "label": "2025-11-12_20-35-43",
            "content": "@@ -1274,1075 +1274,8 @@\n ap)%0A\n-        elif cmd == 'insert':%0A            # insert %3Ccalibre%3E %3Cdureza%3E %3Ctamanho%3E%0A            if lap is None:%0A                # ignore if not initialized%0A                continue%0A            if len(parts) %3C 4:%0A                # malformed%0A                continue%0A            try:%0A                gcal = float(parts%5B1%5D)%0A            except ValueError:%0A                # malformed calibre%0A                print('fail: calibre incompat%C3%ADvel')%0A                continue%0A            dureza = parts%5B2%5D%0A            try:%0A                tamanho = int(parts%5B3%5D)%0A            except ValueError:%0A                # malformed tamanho%0A                continue%0A            # precision compare%0A            if abs(gcal - lap.calibre) %3E 1e-6:%0A                print('fail: calibre incompat%C3%ADvel')%0A                continue%0A            # accept and append representation to tambor (as last element)%0A            s = str(gcal)%0A            if '.' in s:%0A                s = s.rstrip('0').rstrip('.')%0A            grafite_repr = f%22%5B%7Bs%7D:%7Bdureza%7D:%7Btamanho%7D%5D%22%0A            lap.tambor.append(grafite_repr)%0A\n %0A%0Aif\n",
            "lines": "51"
        },
        {
            "label": "2025-11-13_13-44-29",
            "content": "@@ -1454,16 +1454,938 @@\n %0A       \n+     if len(parts) %3C 4:%0A                # malformed%0A                continue%0A            try:%0A                gcal = float(parts%5B1%5D)%0A            except ValueError:%0A                # malformed calibre%0A                print('fail: calibre incompat%C3%ADvel')%0A                continue%0A            dureza = parts%5B2%5D%0A            try:%0A                tamanho = int(parts%5B3%5D)%0A            except ValueError:%0A                # malformed tamanho%0A                continue%0A            # precision compare%0A            if abs(gcal - lap.calibre) %3E 1e-6:%0A                print('fail: calibre incompat%C3%ADvel')%0A                continue%0A            # accept and append representation to tambor (as last element)%0A            s = str(gcal)%0A            if '.' in s:%0A                s = s.rstrip('0').rstrip('.')%0A            grafite_repr = f%22%5B%7Bs%7D:%7Bdureza%7D:%7Btamanho%7D%5D%22%0A            lap.tambor.append(grafite_repr)%0A%0A%0Aif __name__ == '__main__':%0A    main()\n %0A# ...ex\n",
            "lines": "81"
        },
        {
            "label": "2025-11-13_13-51-57",
            "content": "@@ -1458,930 +1458,8 @@\n     \n-     if len(parts) %3C 4:%0A                # malformed%0A                continue%0A            try:%0A                gcal = float(parts%5B1%5D)%0A            except ValueError:%0A                # malformed calibre%0A                print('fail: calibre incompat%C3%ADvel')%0A                continue%0A            dureza = parts%5B2%5D%0A            try:%0A                tamanho = int(parts%5B3%5D)%0A            except ValueError:%0A                # malformed tamanho%0A                continue%0A            # precision compare%0A            if abs(gcal - lap.calibre) %3E 1e-6:%0A                print('fail: calibre incompat%C3%ADvel')%0A                continue%0A            # accept and append representation to tambor (as last element)%0A            s = str(gcal)%0A            if '.' in s:%0A                s = s.rstrip('0').rstrip('.')%0A            grafite_repr = f%22%5B%7Bs%7D:%7Bdureza%7D:%7Btamanho%7D%5D%22%0A            lap.tambor.append(grafite_repr)%0A%0A%0Aif __name__ == '__main__':%0A    main()\n %0A# .\n",
            "lines": "53"
        },
        {
            "label": "2025-11-13_13-52-06",
            "content": "@@ -368,26 +368,8 @@\n oin(\n-f'%5B%7Bg%7D%5D' for g in \n self\n@@ -2267,16 +2267,17 @@\n epr = f%22\n+%5B\n %7Bs%7D:%7Bdur\n@@ -2290,16 +2290,17 @@\n tamanho%7D\n+%5D\n %22%0A      \n@@ -2341,602 +2341,8 @@\n pr)%0A\n-        elif cmd == 'pull':%0A            if lap is None:%0A                continue%0A            # if bico occupied -%3E fail%0A            if lap.bico:%0A                print('fail: ja existe grafite no bico')%0A                continue%0A            if not lap.tambor:%0A                # nothing to pull; ignore%0A                continue%0A            # pull first grafite from tambor to bico (FIFO)%0A            g = lap.tambor.pop(0)%0A            lap.bico = %5Bg%5D%0A        elif cmd == 'remove':%0A            if lap is None:%0A                continue%0A            # remove grafite from bico%0A            lap.bico = %5B%5D%0A\n %0A%0Aif\n",
            "lines": "81"
        },
        {
            "label": "2025-11-13_13-56-53",
            "content": "@@ -1183,32 +1183,365 @@\n if lap is None:%0A\n+                print('lapiseira nao inicializada')%0A            else:%0A                print(lap)%0A        elif cmd == 'insert':%0A            # insert %3Ccalibre%3E %3Cdureza%3E %3Ctamanho%3E%0A            if lap is None:%0A                # ignore if not initialized%0A                continue%0A            if len(parts) %3C 4:%0A                # malformed%0A\n                 \n",
            "lines": "99"
        },
        {
            "label": "2025-11-13_14-05-10",
            "content": "@@ -1195,341 +1195,8 @@\n ne:%0A\n-                print('lapiseira nao inicializada')%0A            else:%0A                print(lap)%0A        elif cmd == 'insert':%0A            # insert %3Ccalibre%3E %3Cdureza%3E %3Ctamanho%3E%0A            if lap is None:%0A                # ignore if not initialized%0A                continue%0A            if len(parts) %3C 4:%0A                # malformed%0A\n     \n",
            "lines": "89"
        },
        {
            "label": "2025-11-13_14-05-21",
            "content": "@@ -1292,982 +1292,8 @@\n ap)%0A\n-        elif cmd == 'pull':%0A            if lap is None:%0A                continue%0A            # if there's already graphite in bico -%3E fail%0A            if lap.bico:%0A                print('fail: ja existe grafite no bico')%0A            else:%0A                if not lap.tambor:%0A                    # nothing to pull%0A                    continue%0A                # pull from front of tambor%0A                g = lap.tambor.pop(0)%0A                lap.bico = %5Bg%5D%0A        elif cmd == 'remove':%0A            if lap is None:%0A                continue%0A            # remove graphite from bico if present%0A            if lap.bico:%0A                lap.bico = %5B%5D%0A        elif cmd == 'write':%0A            if lap is None:%0A                continue%0A            if not lap.bico:%0A                print('fail: nao existe grafite no bico')%0A            else:%0A                # consumption not implemented yet for these tests%0A                # simply keep bico as is for tests 09-10%0A                pass%0A\n     \n",
            "lines": "99"
        },
        {
            "label": "2025-11-13_14-12-21",
            "content": "@@ -3982,8 +3982,9 @@\n  code...\n+%0A\n",
            "lines": "127"
        },
        {
            "label": "2025-11-13_14-14-21",
            "content": "@@ -1,4645 +1,3404 @@\n-%0Afrom typing import List, Optional%0A%0A%0Aclass Lapiseira:%0A    def __init__(self, calibre: float) -%3E None:%0A        self.calibre = float(calibre)%0A        # bico holds either None or a dict %7B'calibre':float,'dureza':str,'tamanho':int%7D%0A        self.bico: Optional%5Bdict%5D = None%0A        # tambor is a FIFO list of grafite dicts%0A        self.tambor: List%5Bdict%5D = %5B%5D%0A%0A    def __str__(self) -%3E str:%0A        if not self.bico:%0A            bico_str = '%5B%5D'%0A        else:%0A            bico_str = f%22%5B%7Bself.bico%5B'calibre'%5D%7D:%7Bself.bico%5B'dureza'%5D%7D:%7Bself.bico%5B'tamanho'%5D%7D%5D%22%0A        if not self.tambor:%0A            tambor_str = '%3C%3E'%0A        else:%0A            tambor_str = '%3C' + ''.join(f%22%5B%7Bg%5B'calibre'%5D%7D:%7Bg%5B'dureza'%5D%7D:%7Bg%5B'tamanho'%5D%7D%5D%22 for g in self.tambor) + '%3E'%0A        s = str(self.calibre)%0A        if '.' in s:%0A            s = s.rstrip('0').rstrip('.')%0A        return f%22calibre: %7Bs%7D, bico: %7Bbico_str%7D, tambor: %7Btambor_str%7D%22%0A%0A%0Adef main() -%3E None:%0A    import sys%0A%0A    lap: Optional%5BLapiseira%5D = None%0A    for line in sys.stdin:%0A        line = line.strip()%0A        if not line:%0A            continue%0A        print(f%22$%7Bline%7D%22)%0A        parts = line.split()%0A        cmd = parts%5B0%5D%0A        if cmd == 'end':%0A            break%0A        if cmd == 'init':%0A            if len(parts) %3E= 2:%0A                try:%0A                    calibre = float(parts%5B1%5D)%0A                except ValueError:%0A                    calibre = 0.0%0A                lap = Lapiseira(calibre)%0A            else:%0A                continue%0A        elif cmd == 'show':%0A            if lap is None:%0A                print('lapiseira nao inicializada')%0A            else:%0A                print(lap)%0A        elif cmd == 'pull':%0A            if lap is None:%0A                continue%0A            # if there's already graphite in bico -%3E fail%0A            if lap.bico is not None:%0A                print('fail: ja existe grafite no bico')%0A            else:%0A                if not lap.tambor:%0A                    # nothing to pull%0A                    continue%0A                # pull from front of tambor%0A                g = lap.tambor.pop(0)%0A                lap.bico = g%0A        elif cmd == 'remove':%0A            if lap is None:%0A                continue%0A            # remove graphite from bico if present%0A            lap.bico = None%0A        elif cmd == 'write':%0A            if lap is None:%0A                continue%0A            if not lap.bico:%0A                print('fail: nao existe grafite no bico')%0A            else:%0A                HARDNESS = %7B%0A                    'HB': 1,%0A                    '2B': 2,%0A                    '4B': 4,%0A                    '6B': 6,%0A                %7D%0A                g = lap.bico%0A                dureza = g%5B'dureza'%5D%0A                consumo = HARDNESS.get(dureza, 0)%0A                tamanho = g%5B'tamanho'%5D%0A                # if already %3C=10 -%3E tamanho insuficiente%0A                if tamanho %3C= 10:%0A                    print('fail: tamanho insuficiente')%0A                    continue%0A                # usable mm excluding last 10mm%0A                utilizavel = tamanho - 10%0A                if utilizavel %3E= consumo:%0A                    # full sheet written%0A                    g%5B'tamanho'%5D = tamanho - consumo%0A                    # if becomes %3C=10 it's still kept in bico (as tests expect)%0A                else:%0A                    # consume what is possible and report incomplete%0A                    # reduce to 10 and report incomplete%0A                    g%5B'tamanho'%5D = 10%0A                    print('fail: folha incompleta')%0A        elif cmd == 'insert':%0A            # insert %3Ccalibre%3E %3Cdureza%3E %3Ctamanho%3E%0A            if lap is None:%0A                # ignore if not initialized%0A                continue%0A            if len(parts) %3C 4:%0A                # malformed%0A                continue%0A            try:%0A                gcal = float(parts%5B1%5D)%0A            except ValueError:%0A                # malformed calibre%0A                print('fail: calibre incompat%C3%ADvel')%0A                continue%0A            dureza = parts%5B2%5D%0A            try:%0A                tamanho = int(parts%5B3%5D)%0A            except ValueError:%0A                # malformed tamanho%0A                continue%0A            # precision compare%0A            if abs(gcal - lap.calibre) %3E 1e-6:%0A                print('fail: calibre incompat%C3%ADvel')%0A                continue%0A            # accept and append representation to tambor (as last element)%0A            s = str(gcal)%0A            if '.' in s:%0A                s = s.rstrip('0').rstrip('.')%0A            # store as dict%0A            lap.tambor.append(%7B'calibre': s, 'dureza': dureza, 'tamanho': tamanho%7D)%0A        # end command loop%0A%0A%0Aif __name__ == '__main__':%0A    main()%0A# ...existing code...\n+@@ -145,177 +145,33 @@%0A     %0A-# bico holds either None or a dict %257B'calibre':float,'dureza':str,'tamanho':int%257D%250A        self.bico: Optional%255Bdict%255D = None%250A        # tambor is a FIFO list of grafite dicts%0A+self.bico: List%255Bstr%255D = %255B%255D%0A %250A   %0A@@ -193,20 +193,19 @@%0A r: List%255B%0A-dict%0A+str%0A %255D = %255B%255D%250A%250A%0A@@ -246,139 +246,49 @@%0A     %0A-if not self.bico:%250A            bico_str = '%255B%255D'%250A        else:%250A            bico_str = f%2522%255B%257Bself.bico%255B'calibre'%255D%257D:%257Bself.bico%255B'dureza'%255D%257D:%0A+bico_str = '%255B%255D' if not self.bico else f%2522%255B%0A %257Bsel%0A@@ -294,25 +294,17 @@%0A lf.bico%255B%0A-'tamanho'%0A+0%0A %255D%257D%255D%2522%250A   %0A@@ -312,159 +312,72 @@%0A     %0A-if not self.tambor:%250A            tambor_str = '%253C%253E'%250A        else:%250A            tambor_str = '%253C' + ''.join(f%2522%255B%257Bg%255B'calibre'%255D%257D:%257Bg%255B'dureza'%255D%257D:%257Bg%255B'tamanho'%255D%257D%255D%2522%0A+tambor_str = '%253C%253E' if not self.tambor else '%253C' + ''.join(f'%255B%257Bg%257D%255D'%0A  for%0A@@ -1454,20 +1454,8 @@%0A bico%0A- is not None%0A :%250A  %0A@@ -1738,17 +1738,19 @@%0A .bico = %0A-g%0A+%255Bg%255D%0A %250A       %0A@@ -1876,16 +1876,45 @@%0A present%250A%0A+            if lap.bico:%250A    %0A         %0A@@ -1928,20 +1928,18 @@%0A .bico = %0A-None%0A+%255B%255D%0A %250A       %0A@@ -2138,1030 +2138,135 @@%0A     %0A-HARDNESS = %257B%250A                    'HB': 1,%250A                    '2B': 2,%250A                    '4B': 4,%250A                    '6B': 6,%250A                %257D%250A                g = lap.bico%250A                dureza = g%255B'dureza'%255D%250A                consumo = HARDNESS.get(dureza, 0)%250A                tamanho = g%255B'tamanho'%255D%250A                # if already %253C=10 -%253E tamanho insuficiente%250A                if tamanho %253C= 10:%250A                    print('fail: tamanho insuficiente')%250A                    continue%250A                # usable mm excluding last 10mm%250A                utilizavel = tamanho - 10%250A                if utilizavel %253E= consumo:%250A                    # full sheet written%250A                    g%255B'tamanho'%255D = tamanho - consumo%250A                    # if becomes %253C=10 it's still%0A+# consumption not implemented yet for these tests%250A                # simply%0A  ke%0A+e%0A p%0A-t in%0A  bico %0A-(%0A as %0A-tests expect)%250A                else:%250A                    # consume what is possible and report incomplete%250A                    # reduce to 10 and report incomplete%250A                    g%255B'tamanho'%255D = 10%250A                    print('fail: folha incompleta')%0A+is for tests 09-10%250A                pass%0A %250A   %0A@@ -3246,134 +3246,686 @@%0A     %0A-# store as dict%250A            lap.tambor.append(%257B'calibre': s, 'dureza': dureza, 'tamanho': tamanho%257D)%250A        # end command loop%0A+grafite_repr = f%2522%257Bs%257D:%257Bdureza%257D:%257Btamanho%257D%2522%250A            lap.tambor.append(grafite_repr)%250A        elif cmd == 'pull':%250A            if lap is None:%250A                continue%250A            # if bico occupied -%253E fail%250A            if lap.bico:%250A                print('fail: ja existe grafite no bico')%250A                continue%250A            if not lap.tambor:%250A                # nothing to pull; ignore%250A                continue%250A            # pull first grafite from tambor to bico (FIFO)%250A            g = lap.tambor.pop(0)%250A            lap.bico = %255Bg%255D%250A        elif cmd == 'remove':%250A            if lap is None:%250A                continue%250A            # remove grafite from bico%250A            lap.bico = %255B%255D%0A %250A%250A%250Ai%0A\n",
            "lines": "62"
        },
        {
            "label": "2025-11-13_14-18-38",
            "content": "\nfrom typing import List, Optional\n\n\nclass Lapiseira:\n    def __init__(self, calibre: float) -> None:\n        self.calibre = float(calibre)\n        # bico holds either None or a dict {'calibre':float,'dureza':str,'tamanho':int}\n        self.bico: Optional[dict] = None\n        # tambor is a FIFO list of grafite dicts\n        self.tambor: List[dict] = []\n\n    def __str__(self) -> str:\n        if not self.bico:\n            bico_str = '[]'\n        else:\n            bico_str = f\"[{self.bico['calibre']}:{self.bico['dureza']}:{self.bico['tamanho']}]\"\n        if not self.tambor:\n            tambor_str = '<>'\n        else:\n            tambor_str = '<' + ''.join(f\"[{g['calibre']}:{g['dureza']}:{g['tamanho']}]\" for g in self.tambor) + '>'\n        s = str(self.calibre)\n        if '.' in s:\n            s = s.rstrip('0').rstrip('.')\n        return f\"calibre: {s}, bico: {bico_str}, tambor: {tambor_str}\"\n\n\ndef main() -> None:\n    import sys\n\n    lap: Optional[Lapiseira] = None\n    for line in sys.stdin:\n        line = line.strip()\n        if not line:\n            continue\n        print(f\"${line}\")\n        parts = line.split()\n        cmd = parts[0]\n        if cmd == 'end':\n            break\n        if cmd == 'init':\n            if len(parts) >= 2:\n                try:\n                    calibre = float(parts[1])\n                except ValueError:\n                    calibre = 0.0\n                lap = Lapiseira(calibre)\n            else:\n                continue\n        elif cmd == 'show':\n            if lap is None:\n                print('lapiseira nao inicializada')\n            else:\n                print(lap)\n        elif cmd == 'pull':\n            if lap is None:\n                continue\n            # if there's already graphite in bico -> fail\n            if lap.bico is not None:\n                print('fail: ja existe grafite no bico')\n            else:\n                if not lap.tambor:\n                    # nothing to pull\n                    continue\n                # pull from front of tambor\n                g = lap.tambor.pop(0)\n                lap.bico = g\n        elif cmd == 'remove':\n            if lap is None:\n                continue\n            # remove graphite from bico if present\n            lap.bico = None\n        elif cmd == 'write':\n            if lap is None:\n                continue\n            if not lap.bico:\n                print('fail: nao existe grafite no bico')\n            else:\n                HARDNESS = {\n                    'HB': 1,\n                    '2B': 2,\n                    '4B': 4,\n                    '6B': 6,\n                }\n                g = lap.bico\n                dureza = g['dureza']\n                consumo = HARDNESS.get(dureza, 0)\n                tamanho = g['tamanho']\n                # if already <=10 -> tamanho insuficiente\n                if tamanho <= 10:\n                    print('fail: tamanho insuficiente')\n                    continue\n                # usable mm excluding last 10mm\n                utilizavel = tamanho - 10\n                if utilizavel >= consumo:\n                    # full sheet written\n                    g['tamanho'] = tamanho - consumo\n                    # if becomes <=10 it's still kept in bico (as tests expect)\n                else:\n                    # consume what is possible and report incomplete\n                    # reduce to 10 and report incomplete\n                    g['tamanho'] = 10\n                    print('fail: folha incompleta')\n        elif cmd == 'insert':\n            # insert <calibre> <dureza> <tamanho>\n            if lap is None:\n                # ignore if not initialized\n                continue\n            if len(parts) < 4:\n                # malformed\n                continue\n            try:\n                gcal = float(parts[1])\n            except ValueError:\n                # malformed calibre\n                print('fail: calibre incompat\u00edvel')\n                continue\n            dureza = parts[2]\n            try:\n                tamanho = int(parts[3])\n            except ValueError:\n                # malformed tamanho\n                continue\n            # precision compare\n            if abs(gcal - lap.calibre) > 1e-6:\n                print('fail: calibre incompat\u00edvel')\n                continue\n            # accept and append representation to tambor (as last element)\n            s = str(gcal)\n            if '.' in s:\n                s = s.rstrip('0').rstrip('.')\n            # store as dict\n            lap.tambor.append({'calibre': s, 'dureza': dureza, 'tamanho': tamanho})\n        # end command loop\n\n\nif __name__ == '__main__':\n    main()\n# ...existing code...",
            "lines": "139"
        }
    ]
}